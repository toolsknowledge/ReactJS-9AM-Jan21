<!--
    function
    ========
        - functions are used to reuse the business logic.

        - we will define the functions by using "function" keyword.

        - we have following types of functions upto "ES11"

                1) Named Functions

                2) Anonymous Functions / Arrow Functions / Lamda Functions / CallBack Functions / Fat Arrow Functions

                3) Rest Parameters in Functions

                4) Default Parameters in Functions

                5) Constructor Functions

                6) Generators

                7) IIFE  (Immidiate Invokable Functional Expressions)

                8) Optional Parameters in Functions

    Named Functions
    ===============

        - The function with the particular name called as Named Function.

    Syntax.
    ------
        //definition
        function functionname(parameters){
            //business logic
        };

        //call the function
        functionname(arguments);
-->

<!--
    <script>
        function fun_one(){
            return "welcome to named functions";
        };

        console.log( fun_one );      //function definition
        console.log( fun_one() );    //output
    </script>
-->


<!--
<script>
    function fun_one(param1,param2,param3){
        console.log( param1, param2, param3 );
    };
    fun_one("Angular","NodeJS","MongoDB");         //Angular NodeJS MongoDB
    fun_one("ReactJS","Deno","MySQL");             //ReactJS Deno MySQL
    fun_one("VueJS","NodeJS","SQLServer");         //VueJS NodeJS SQLServer
    fun_one();                                     //undefined undefined undefined
</script>
-->

<!--
<script>
    function fun_one(){
        return fun_two;
    };
    function fun_two(){
        return "Hello";
    };
    console.log( fun_one()() );     //Hello
</script>
-->


<!--
<script>
     var my_arr = [];

     function fun_one(){
        return "Hello";
     };

    for(var i=0;i<5;i++){
        my_arr.push( fun_one );
    };

    console.log( my_arr.length );   //5

    for(var j=0;j<my_arr.length;j++){
        console.log( my_arr[j]() );
    };

</script>
-->


<!--
<script>
    function fun_one(param1){
        console.log( param1() );
    };

    function fun_two(){
        return "Hello";
    };

    fun_one( fun_two );     //Hello
</script>
-->



<!--
    The function without name called as Anonymous function.

    Anonymous functions also called as arrow functions/fat arrow functions/lamda functions/callback functions.

    Syntax
    ======
    
    //function definition
    var/let/const variablename = (parameters)=>{
        //business logic
    };

    //calling the function
    variablename(arguments)
-->

<!--
<script>
    let fun_one = ()=>{
        return "Hello";  
    };
    console.log( fun_one );
    console.log( fun_one() );
</script>
-->

<!--
<script>
    let my_fun = (param1,param2,param3)=>{
        console.log(param1,param2,param3);
    };
    my_fun("Angular","NodeJS","MongoDB");     //Angular NodeJS MongoDB
    my_fun("ReactJS","Deno","MySQL");         //ReactJS Deno MySQL
    my_fun("VueJS","NodeJS","SQLServer");     //VueJS NodeJS SQLServer
</script>
-->
<!--
<script>
   let my_fun = ()=>{
       return ()=>{
         return "Hello";
       };
   }; 
   console.log( my_fun()() );     //Hello
</script>
-->

<!--
<script>
    let networkCall = (param1,param2)=>{
        console.log( param1(), param2() );
    };
    networkCall(()=>{
        return "Success";
    },()=>{
        return "Error";
    });     //Success Error
</script>
-->


<!--
    rest parameters, are used to hold the multiple values.

    rest parameters introduced in "ES6"

    we will represent rest parameter by using "..."

    "..." called as "rest parameter"
-->

<!--
<script>
    function fun_one(...arg1){
        console.log(arg1);
    };
    fun_one("Hello_1");                     //["Hello_1"]
    fun_one("Hello_1","Hello_2");           //["Hello_1", "Hello_2"]
    fun_one();                              //[]
    fun_one(undefined);                     //[undefined]
    fun_one(null);                          //[null]
    fun_one(undefined,null);                //[undefined, null]
</script>
-->

<!--
    <script>
        function fun_one(...arg2,arg1){

        };
        //rest parameter, always should be last formal parameter
    </script>
-->

<!--
<script>
    function fun_one(arg1,...arg2){
        console.log(arg1, arg2);
    };
    fun_one("Hello_1");                             //Hello_1 []
    fun_one("Hello_1","Hello_2");                   //Hello_1 ["Hello_2"]
    fun_one("Hello_1","Hello_1","Hello_2");         //Hello_1 (2)Â ["Hello_1", "Hello_2"]
    fun_one();                                      //undefined []
    fun_one(undefined,undefined);                   //undefined [undefined]
    fun_one(null,null);                             //null [null]
</script>
-->

<!--
<script>
    function fun_one(...arg1,...arg2){}
    //we can supply only one rest parameter, that rest parameter also should be last occurance
</script>
-->




<!--
    Default Parameters in Functions
    -------------------------------
        - while defining the functions, we will initilize parameters with default values.

        - ES6
-->

<!--
<script>
    function fun_one(arg1="ReactJS",arg2="NodeJS",arg3="MongoDB"){
        console.log( arg1, arg2, arg3 );
    };
    fun_one();                          //ReactJS NodeJS MongoDB
    fun_one("Angular11");               //Angular11 NodeJS MongoDB
    fun_one(undefined,
            undefined,
            undefined);                 //ReactJS NodeJS MongoDB
    fun_one(null,
            null,
            null);                      //null null null
    fun_one(undefined,
            "Deno",
            null);                      //ReactJS Deno null
</script>
-->


<!--
<script>
    function fun_one(arg1,arg2="Hello_2"){
        console.log(arg1,arg2);
    };
    fun_one();                                  //undefined "Hello_2"
    fun_one("Hello_1");                         //Hello_1 Hello_2
    fun_one(undefined,undefined);               //undefined "Hello_2"
    fun_one(null,null);                         //null null
</script>
-->

<!--
<script>
    function fun_one(arg2="Hello_2",arg1){
        console.log(arg2,arg1);
    };
    fun_one();                      //Hello_2 undefined
    fun_one(undefined);             //Hello_2 undefined
    fun_one(null,undefined);        //null undefined
</script>
-->
<!--
<script>
    function fun_one(arg1,arg2="Hello_2",...arg3){
        console.log( arg1, arg2, arg3 );
    };
    fun_one();                                          //undefined "Hello_2" []
    fun_one("Hello_1");                                 //Hello_1 Hello_2 []
    fun_one("Hello_1",undefined,"Hello_3");             //Hello_1 Hello_2 ["Hello_3"]
</script>
-->



<!--
    Constructor Functions
    =====================
        - before ES6 Version, we will create classes by using "Constructor Functions".

        - in Constructor Functions, all the members(functions and variables) will start with "this" keyword.

        - we will create object the classes by using "new" keyword.
-->

<!--
<script>
    function class_one(){
        this.sub_one = "ReactJS";
        this.sub_two = "NodeJS";
        this.sub_three = "MongoDB";
    };
    let obj = new class_one();
    console.log( obj.sub_one, obj.sub_two, obj.sub_three );             //ReactJS NodeJS MongoDB
</script>
-->


<!--
<script>
    function class_one(arg1,arg2,arg3){
        this.var_one = arg1;
        this.var_two = arg2;
        this.var_three = arg3;
    };
    let obj1 = new class_one("Angular11","Node","MongoDB");
    console.log( obj1.var_one, obj1.var_two, obj1.var_three );    //Angular11 Node MongoDB

    let obj2 = new class_one("ReactJS","Deno","MySQL");
    console.log( obj2.var_one, obj2.var_two, obj2.var_three );    //ReactJS Deno MySQL
</script>
-->


<!--
<script>
    function class_one(){
        
        this.fun_one = function(){
            return "Hello_1";
        };

        this.fun_two = function(){
            return "Hello_2";
        };

        this.fun_three = function(){
            return "Hello_3";
        };
    };
    let obj = new class_one();
    console.log( obj.fun_one(),
                obj.fun_two(),
                obj.fun_three() );     //Hello_1 Hello_2 Hello_3
</script>
-->

<!--
<script>
    function class_one(){
        this.sub_one = "ReactJS";
        this.sub_two = "NodeJS";
        this.sub_three = "MongoDB";

        this.getSubOne = function(){
            return this.sub_one;
        };

        this.getSubTwo = function(){
            return this.sub_two;
        };

        this.getSubThree = function(){
            return this.sub_three;
        };
    };
    let obj1 = new class_one();
    console.log( obj1.getSubOne(),obj1.getSubTwo(),obj1.getSubThree() );   //ReactJS NodeJS MongoDB

</script>
-->

<!--
<script>
    function class_one(){

    };
    
    class_one.prototype.msg1 = "Hello_1";
    class_one.prototype.getMsg = function(){
        return this.msg1;
    };

    let obj = new class_one();
    console.log( obj.getMsg() );     //Hello_1
</script>
-->


<!--
    inheritance
    ===========
        - getting the properties and functions from parent class to child class.

        //single level inheritance
<script>
    function class_one(){

    };
    class_one.prototype.var_one = "Hello_1";

    function class_two(){

    };
    class_two.prototype = Object.create(class_one.prototype);
    class_two.prototype.var_two = "Hello_2";

    let obj = new class_one();
    console.log( obj.var_one );                             //Hello_1

    let obj1 = new class_two();
    console.log( obj1.var_one, obj1.var_two );              //Hello_1 Hello_2
</script>
-->


<!--
<script>
    
    //multi level inhiratance
    function class_one(){
    };
    class_one.prototype.meanStack = function(){
        return "Angular";
    };

    function class_two(){
    };
    class_two.prototype = Object.create(class_one.prototype);
    class_two.prototype.mernStack = function(){
        return "ReactJS";
    };

    function class_three(){
    };
    class_three.prototype = Object.create(class_two.prototype);
    class_three.prototype.mevnStack = function(){
        return "VueJS";
    };

    let obj1 = new class_one();
    console.log( obj1.meanStack() );                                                //Angular

    let obj2 = new class_two();
    console.log( obj2.meanStack(), obj2.mernStack() );                              //Angular ReactJS

    let obj3 = new class_three();
    console.log( obj3.meanStack(), obj3.mernStack(), obj3.mevnStack() );            //Angular ReactJS VueJS
</script>
-->


<!--
<script>
    //overriding
    //overriding the parent class functionality with child class functionality called as overrising
    function class_one(){

    };
    class_one.prototype.getDBData = function(){
        return "MySQL Data Soon...!";
    };

    function class_two(){

    };
    class_two.prototype = Object.create(class_one.prototype);
    class_two.prototype.getDBData = function(){
        return "MongoDB Data Soon...!";
    };
    let obj = new class_two();
    console.log( obj.getDBData() );                 //MongoDB Data Soon...!

    let obj1 = new class_one();
    console.log( obj1.getDBData() );                //MySQL Data Soon...!
</script>
-->


<!--
    Generators   

    - we will control flow of "execution of code" with the help of generators.

    - generator functions will prefix with "*"

    - in generator functions all the statements prefix with "yield".

    - we will iterate the data by using cursors.
-->

<!--
<script>
    function *fun_one(){
        yield "Hello_1";
        yield "Hello_2";
        yield "Hello_3";
        yield "Hello_4";
        yield "Hello_5";
    };
    let cursor = fun_one();
    console.log( cursor.next() );
    console.log( cursor.next() );
    console.log( cursor.next() );
    console.log( cursor.next() );
    console.log( cursor.next() );
    console.log( cursor.next() );
</script>
-->


<!--
<script>
    function *fun_one(){
        yield 100;
        yield *fun_two();
        yield 300;
    };
    function *fun_two(){
        yield 200;
        yield "Hello";
    };
    let cursor = fun_one();
    console.log( cursor.next() );
    console.log( cursor.next() );
    console.log( cursor.next() );
    console.log( cursor.next() );
</script>
-->
<script>
    function *fun_one(){
        yield "Hello_1";
        yield "Hello_2";
        return "Hello_3";
        yield "Hello_4";
    };
    let cursor = fun_one();
    for(let i=0;i<4;i++){
        console.log( cursor.next() );
    };
</script>











































































































































































































































































































































































































































































































































































































